<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Act Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="language.html"><strong aria-hidden="true">1.</strong> Language Reference</a></li><li class="chapter-item expanded "><a href="backends.html"><strong aria-hidden="true">2.</strong> Backends</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="smt.html"><strong aria-hidden="true">2.1.</strong> SMT</a></li><li class="chapter-item expanded "><a href="coq.html"><strong aria-hidden="true">2.2.</strong> Coq</a></li><li class="chapter-item expanded "><a href="hevm.html"><strong aria-hidden="true">2.3.</strong> Hevm</a></li></ol></li><li class="chapter-item expanded "><a href="internals.html"><strong aria-hidden="true">3.</strong> Internals</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Act Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Act is a high level specification language for evm programs. The core aim is to allow for easy
refinement. We want to make it as easy as possible for development teams to define a high level
specification, which can then either be used &quot;upwards&quot; to prove higher level properties or
&quot;downwards&quot; to demonstrate that an implementation in EVM bytecode conforms to the spec.</p>
<p>Act currently integrates with the following tools:</p>
<ul>
<li>Hevm: automated refinement proof between the act spec and a given evm bytecode object</li>
<li>SMT: automated proof of invariants and postconditions</li>
<li>Coq: manual proof of high level properties against a model derived from the Act spec</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>At a very high level Act is a kind of mathy english over the EVM, where contracts are defined as a
set of pure functions taking a given EVM state (i.e. storage &amp; blockchain context) and some calldata
and producing a new EVM state (<code>(EVM, Calldata) -&gt; EVM</code>).</p>
<p>A specification of a contract written in Act consists of a constructor and a set of behaviours:</p>
<p>The constructor specification defines the structure of the contract’s state, the initial value of
the state, and a list of invariants that the contract should satisfy.</p>
<p>Each behaviour specification determines how a contract method updates the state, the method’s return
value (if any), and any conditions that must be satisfied in order for the state update to be
applied.</p>
<p>Alternatively, they can be thought of as an initial state and a set of state transitions,
determining an inductively defined state transition system.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>The types of Act consist of three basic primitives: Integers, Booleans and Bytestrings. Integers are
unbounded, with true integer operations. However, as our integer expressions will often represent
words in the EVM, we allow ourselves a slight abuse of notation and denote by uintN/intN integers
together with the constraint that the value fits into a uintN/intN. If any operation could over- or
underflow this bound, the constraint will be unfulfilled and the specification will fail to prove.</p>
<p>Using conventional ABI types for typing also allows us to specify function signatures in a concise
way. As an example, consider this specification of a trivial contract that adds two numbers and
stores the result on chain:</p>
<pre><code>constructor of Add
interface constructor()

creates

  uint result := 0

behaviour add of Add
interface add(uint x, uint y)

iff in range uint

   x + y

storage

  result =&gt; x + y

returns x + y
</code></pre>
<p>Expressed in English and math, this specification would read:</p>
<p>The contract <code>Add</code> has a single state variable, named <code>result</code>, which is an integer such that <code>0 &lt;= result &lt; 2^256</code>.</p>
<p>Given any pair of integers <code>x</code> and <code>y</code>, s.t. <code>0 &lt;= x &lt; 2^256</code> and <code>0 &lt;= y &lt; 2^256</code>, an ABI encoded call to the contract <code>Add</code> with the signature <code>add(uint256,uint256)</code>, with its respective arguments named <code>x</code> and <code>y</code>, will:</p>
<ul>
<li>store <code>x + y</code> in <code>result</code> and return <code>x + y</code> if <code>0 &lt;= x + y &lt; 2^256</code></li>
<li>revert otherwise</li>
</ul>
<h1 id="syntax-of-the-act-language"><a class="header" href="#syntax-of-the-act-language">Syntax of the Act language</a></h1>
<p>A specification of a contract written in <code>act</code> consists of a
<code>constructor</code> and a set of <code>behaviours</code>.</p>
<p>The <code>constructor</code> specification defines the structure of the contract
state, the initial value for the state, and a list of invariants that
the contract should satisfy.</p>
<p>Each <code>behaviour</code> specification determines how a contract method updates
the state, and its return value, and the conditions that must be
satisfied in order for it to be applied.</p>
<p>Alternatively, they can be thought of an initial state and a
set of state transitions, determining an inductively defined
state transition system.</p>
<p>The specifications can be exported to different backends in order to
prove that the claims that are being made hold with respect to an implementation.</p>
<p>This document is a high level description of the syntax of
act specifications.
For a more formal treatment of the syntax, study the
definitions of <a href="https://github.com/ethereum/act/blob/master/src/RefinedAst.hs">RefinedAst.hs</a>.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>The types of Act consist of three basic primitives:
Integers, Booleans and ByteStrings. Integers are unbounded,
with true integer operations. However, as our integer expressions
will often represent words in the EVM, we allow ourselves a slight
abuse of notation and denote by <code>uintN/intN</code> integers together with the
constraint that the value fits into a <code>uintN/intN</code>.</p>
<p>Using conventional ABI types for typing also allows us to specify
function signatures in a concise way.</p>
<p>As an example consider the specification of overflow safe addition:</p>
<pre><code class="language-act">behaviour add of SafeMath
interface add(uint x, uint y)

iff in range uint

   x + y

returns x + y
</code></pre>
<p>In more verbose terms, this specification would read:</p>
<p>Given any pair of integers <code>x</code> and <code>y</code>, s.t. <code>0 &lt;= x &lt; 2^256</code> and
<code>0 &lt;= y &lt; 2^256</code>, an ABI encoded call to the contract <code>SafeMath</code>
with the signature <code>add(uint256,uint256)</code>, and <code>x</code> and <code>y</code>, will:</p>
<ul>
<li>return <code>x + y</code>      if <code>0 &lt;= x + y &lt; 2^256</code></li>
<li>revert              otherwise</li>
</ul>
<h2 id="contructor"><a class="header" href="#contructor">Contructor</a></h2>
<p>A <code>constructor</code> specification is indicated by the
<code>constructor of &lt;contractName&gt;</code> header, as in:</p>
<pre><code class="language-act">constructor of A
</code></pre>
<p>A constructor section consists of the following fields:</p>
<h3 id="interface"><a class="header" href="#interface">interface</a></h3>
<p>Specifying the arguments the constructor takes.
Example:</p>
<pre><code class="language-act">interface constructor(address _owner)
</code></pre>
<h3 id="iff-optional"><a class="header" href="#iff-optional">iff (optional)</a></h3>
<p>The conditions that must be satisfied in order for the contract to be created.
These must be necessary and sufficient conditions, in the sense that if any
condition isn't met, the contract cannot be created.</p>
<p>Example:</p>
<pre><code class="language-act">iff

CALLER == _owner
</code></pre>
<h3 id="creates"><a class="header" href="#creates">creates</a></h3>
<p>Defines the storage layout of the contract.</p>
<p>Example:</p>
<pre><code class="language-act">
creates

  uint256 totalSupply := _totalSupply
  mapping(address =&gt; uint) balanceOf :=  [CALLER := _totalSupply]
</code></pre>
<h3 id="external-storage-changes-optional"><a class="header" href="#external-storage-changes-optional">External storage changes (optional)</a></h3>
<p>If the contract creation updates the state of other contracts,
they should be specified as:</p>
<pre><code class="language-act">contract B
   x =&gt; x + 1

contract C
   y =&gt; y - 1
</code></pre>
<h3 id="ensures-optional"><a class="header" href="#ensures-optional">Ensures (optional)</a></h3>
<p>A list of predicates that should hold over the poststate. All references to storage
variables in <code>ensures</code> sections need to specify whether they talk about the variable's
value in the pre- or the poststate, by using <code>pre(x)</code> or <code>post(x)</code>.
Example:</p>
<pre><code class="language-act">
ensures

   (post(x) == _x) or (pre(x) == _x)
</code></pre>
<h3 id="invariants-optional"><a class="header" href="#invariants-optional">Invariants (optional)</a></h3>
<p>A list of predicates over the state of the contract that should hold before and after
every contract invocation:</p>
<pre><code class="language-act">invariants

  totalSupply = initialSupply
  _k = x * y
</code></pre>
<h2 id="behaviour"><a class="header" href="#behaviour">Behaviour</a></h2>
<p>A <code>behaviour</code> specification is indicated by the
<code>behaviour of &lt;contractName&gt;</code> header, as in:</p>
<pre><code class="language-act">behaviour of A
</code></pre>
<p>and consists of the following fields:</p>
<h3 id="interface-1"><a class="header" href="#interface-1">interface</a></h3>
<p>Specifying which method the behaviour refers to.
Example:</p>
<pre><code class="language-act">interface transfer(address to, uint value)
</code></pre>
<h3 id="iff-optional-1"><a class="header" href="#iff-optional-1">iff (optional)</a></h3>
<p>The conditions that must be satisfied in order for the transition to apply.
These must be necessary and sufficient conditions, in the sense that if any
condition isn't met, a call to the given method must revert.</p>
<p>Example:</p>
<pre><code class="language-act">iff

  balanceOf[CALLER] &gt;= value
  CALLVALUE == 0
</code></pre>
<h3 id="cases-and-state-updates"><a class="header" href="#cases-and-state-updates">cases and state updates</a></h3>
<p>Each behaviour must specify the state changes that happens a result of
a valid call to the method, and its return argument, if any.
All references to storage variables in <code>returns</code> arguments need to
specify whether they talk about the variable's
value in the pre- or the poststate, by using <code>pre(x)</code> or <code>post(x)</code>.</p>
<p>This can be specified in two ways. Either directly, as in:</p>
<pre><code class="language-act">
storage

  balanceOf[CALLER] =&gt; balanceOf[CALLER] - value
  balanceOf[to] =&gt; balanceOf[to] + value

returns post(balanceOf[CALLER])
</code></pre>
<p>or split between a number of cases, as in:</p>
<pre><code class="language-act">case to == CALLER:

   returns -1

case to =/= CALLER:

   storage
     balanceOf[CALLER] =&gt; balanceOf[CALLER] - value
     balanceOf[to] =&gt; balanceOf[to] + value

   returns post(balanceOf[CALLER])
</code></pre>
<p>Note that currently, either a <code>storage</code> or <code>returns</code> section, or both is required in every spec.</p>
<h3 id="external-storage-changes-optional-1"><a class="header" href="#external-storage-changes-optional-1">External storage changes (optional)</a></h3>
<p>If the contract method updates the state of other contracts,
they should be specified as:</p>
<pre><code class="language-act">contract B
   x =&gt; x + 1

contract C
   y =&gt; y - 1
</code></pre>
<h3 id="ensures-optional-1"><a class="header" href="#ensures-optional-1">Ensures (optional)</a></h3>
<p>A list of predicates that should hold over the poststate.
Example:</p>
<pre><code class="language-act">
ensures

   x == _x
</code></pre>
<h2 id="referencing-storage-variables"><a class="header" href="#referencing-storage-variables">Referencing Storage Variables</a></h2>
<p>Storage locations that are read and used in other expressions must be declared in a storage block.</p>
<p>Some examples:</p>
<pre><code class="language-act">storage
  x =&gt; y
  y
</code></pre>
<pre><code class="language-act">storage
  x
  y

returns x + y
``
</code></pre>
<h1 id="backends"><a class="header" href="#backends">Backends</a></h1>
<p>Act currently implements 3 backends natively:</p>
<ul>
<li><a href="./smt.html"><code>SMT</code></a>: automated proof of postcondition and inductive invariants against the spec</li>
<li><a href="./coq.html"><code>Coq</code></a>: manual proof of arbitrary properties against the spec</li>
<li><a href="./hevm.html"><code>Hevm</code></a>: automated equivalence proof between the spec and an implementation in evm</li>
</ul>
<h1 id="smt-backend"><a class="header" href="#smt-backend">SMT Backend</a></h1>
<p>The SMT backend for Act is currently able to automatically prove that:</p>
<ul>
<li>post conditions are implied by pre conditions</li>
<li>contract level invariants hold</li>
</ul>
<p>To perform these proofs, you can simply run <code>act prove --file &lt;PATH_TO_SPEC&gt;</code> against your spec.</p>
<p><code>act prove</code> also accepts the following configuration flags:</p>
<ul>
<li><code>--solver</code>: you can choose to use <code>cvc4</code> or <code>z3</code> as the solver backend. The default is <code>z3</code>.
Sometimes <code>cvc4</code> may be able to prove things that <code>z3</code> cannot (and vice versa). You can also
prove the same properties with multiple solvers to gain confidence that the proofs are not
affected by a bug in the solver itself.</li>
<li><code>--smttimeout</code>: the timeout given for each smt query. This is set to 20s by default.</li>
<li><code>--debug</code>: this prints the raw query dispatched to the SMT solver to stdout. Note that these
queries are machine generated by the <code>sbv</code> library and so are fairly challenging to inspect manually.</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="automatic-market-maker"><a class="header" href="#automatic-market-maker">Automatic Market Maker</a></h3>
<p>As an example consider the following specification of a simplified uniswap style automatic market
maker. For the purposes of this example we focus only on the core logic, and ignore e.g.
interactions with the underlying tokens.</p>
<p>The <code>Amm</code> has two state variables representing its underlying token balances, <code>reserve0</code> and
<code>reserve1</code>. These are initialized to <code>1000</code> units each upon creation.</p>
<p>We define a single invariant, that the product of the two reserves should never decrease. This is an
important safety property, if it is violated, an attacker will be able to execute a sequence of
trades that can drain all funds from the exchange.</p>
<pre><code class="language-act">behaviour init of Amm
interface constructor()

creates

    uint256 reserve0 := 1000
    uint256 reserve1 := 1000

invariants

    1000 * 1000 &lt;= reserve0 * reserve1
</code></pre>
<p>Next, we define the two <code>swap</code> methods, that allow a user to exchange tokens. These methods take an
amount (<code>amt</code>) of input reserves, and the <code>Amm</code> will adjust the size of the other reserve according
to the <code>x * y == k</code> constant product formula.</p>
<pre><code class="language-act">behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 =&gt; reserve0 + amt
    reserve1 =&gt; (reserve0 * reserve1) / (reserve0 + amt)
</code></pre>
<pre><code class="language-act">behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 =&gt; (reserve0 * reserve1) / (reserve1 + amt)
    reserve1 =&gt; reserve1 + amt
</code></pre>
<p>If we run <code>act prove</code> against the above spec, we find that there is in fact an error. If the <code>Amm</code>
starts with <code>reserve0 == 1</code> and <code>reserve1 == 1,000,000</code>, and <code>swap0</code> is called with <code>amt == 2</code>, the
final state of the <code>Amm</code> will be <code>reserve0 == 3</code> and <code>reserve1 == 333,333</code>. In this case <code>3 * 333,333</code> is <code>999,999</code>, and in fact the product of the reserves has decreased slightly due to
imprecision introduced by the EVM's flooring division.</p>
<p>A safe specification for the <code>swap</code> methods is as follows. Notice the extra <code>+1</code> added to the output
reserve in both cases. With this implementation, the rounding error is now in favor of the pool
instead of the trader, and the contract is now safe against this particular attack.</p>
<p>If we again run <code>act prove</code> against the fixed specification, we see that the invariant holds for all
possible executions of the contract.</p>
<pre><code class="language-act">behaviour swap0 of Amm
interface swap0(uint256 amt)

iff in range uint256

    reserve0 + amt

storage

    reserve0 =&gt; reserve0 + amt
    reserve1 =&gt; (reserve0 * reserve1) / (reserve0 + amt) + 1
</code></pre>
<pre><code class="language-act">behaviour swap1 of Amm
interface swap1(uint256 amt)

iff in range uint256

    reserve1 + amt

storage

    reserve0 =&gt; (reserve0 * reserve1) / (reserve1 + amt) + 1
    reserve1 =&gt; reserve1 + amt
</code></pre>
<h3 id="underpowered-invariant"><a class="header" href="#underpowered-invariant">Underpowered Invariant</a></h3>
<p>Due to the inductive nature of the proof, there are some true invariants that the SMT backend is
unable to prove. For example, consider the following state machine:</p>
<pre><code class="language-act">behaviour init of C
interface constructor()

creates
    uint x := 0

invariants
    x &lt; 9

behaviour f of C
interface f()

case x == 0:

    storage
        x =&gt; 1

behaviour g of C
interface g()

case x == 1:

    storage
        x =&gt; 2

behaviour j of C
interface j()

case x == 7:

    storage
        x =&gt; 100
</code></pre>
<p>The contract <code>C</code> can never be in a state were <code>x == 7</code> and so the write of <code>100</code> to <code>x</code> in <code>j()</code> can
never occur, however if we run <code>act prove</code> against this specification, this exact case (<code>x == 7</code>) is
found as a counterexample.</p>
<p>This is due to the inductive nature of the proof: <code>act</code> checks that the invariant holds after
running the constructor, and then for each method assumes that the invariant holds over the pre state
and checks that the invariant holds over the post state.</p>
<p>In the case above, the invariant states that <code>x &lt; 9</code>, and if this is assumed as a precondition, then
the <code>x == 7</code> branch in <code>j()</code> is still reachable.</p>
<p>We can fix this by strengthening the invariant to make the <code>x == 7</code> branch unreachable, in the case
of the spec above, an invariant of <code>x &lt; 7</code> is sufficient, although <code>x &lt; 3</code> is the strongest
invariant of this form that holds over the full transition system.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Although SMT solvers are powerful tools there are some important limitations to be aware of:</p>
<ul>
<li>The invariants proven can only be inductive in nature, and can only be expressed in terms of state
variables and constructor arguments.</li>
<li>SMT solvers do not support the exponentiation operation.</li>
<li>The solver may be unable to prove properties about behaviours making extensive use of non linear
arithmetic (i.e. multiplication or division by a symbolic value). This is an inherent limitation
of all SMT solvers.</li>
</ul>
<h2 id="implementation-strategy"><a class="header" href="#implementation-strategy">Implementation Strategy</a></h2>
<p>For each invariant claim, Act builds an individual SMT query for each behaviour in the transtion
system. If there are no invariant claims defined, then <code>act</code> will insert an implicit invariant of
<code>True</code>, meaning that the postconditions are still checked.</p>
<p>If the behaviour is a constructor, the query asks the solver to find instances where:</p>
<ul>
<li>the preconditions hold</li>
<li>the storage values in the poststate match those specified by the <code>creates</code> block of the constructor</li>
<li>the invariant does not hold over the post state or the postconditions do not hold over the poststate</li>
</ul>
<p>If the behaviour is a method, the query asks the solver to find instances where:</p>
<ul>
<li>the invariant holds over the pre state</li>
<li>the preconditions hold</li>
<li>all storage variables in the prestate are within the range specified by their type</li>
<li>a predicate relating the pre and post state according to the specification in the <code>storage</code> block holds</li>
<li>the invariant does not hold over the post state or the postconditions do not hold over the poststate</li>
</ul>
<p>If all of the queries for an invariant claim return <code>unsat</code>, then two properties have been proved
about the transition system:</p>
<ol>
<li>The invariant holds over the post state</li>
<li>The postconditions hold for every method level behaviour</li>
</ol>
<h1 id="coq"><a class="header" href="#coq">Coq</a></h1>
<p>While the automated proof backend is quite capable, there are still many properties that are too
challenging for automated tools. For this reason Act allows exporting the transition system to the
Coq proof assistant, where manual proofs of arbitrary complexity can be carried out.</p>
<p>A proof assistant provides tools that help to construct proofs. Coq, in particular, is highly
interactive. The user typically builds proofs step by step, with the software giving feedback as the
proof progresses.</p>
<p>The requirements on proofs in a system like Coq, Isabelle, or Lean are quite strict. These tools
only accept proofs that are algorithmically verifiable to be valid series of applications of the
system’s inference rules. This is generally stricter than what is typically expected of pen and
paper proofs, which often omit tedious details in the interest of clarity and concision.</p>
<p>The verification of these proofs is performed in a minimal and well-audited kernel. Although
occasionally bugs have been found in Coq’s and other systems’ kernels, a proof in these systems is
generally quite strong evidence of correctness.</p>
<h2 id="a-brief-introduction-to-proof-in-coq"><a class="header" href="#a-brief-introduction-to-proof-in-coq">A Brief Introduction to Proof in Coq</a></h2>
<p>Coq is a complex system with a steep learning curve, and while a full tutorial on programming in Coq
is out of the scope of this blog post, we can give a little taste of how things work. For a more
thorough introduction, the books Software Foundations and Certified Programming With Dependent Types
are both excellent. Software Foundations in particular is a great introduction for users with little
experience in the fields of formal logic and proof theory.</p>
<p>The Coq system is composed of three languages: a minimal functional programming language (Gallina),
a tactics language for proof construction (Ltac), and a “vernacular” for interaction with the
kernel. Let’s start with the very basics: defining the natural numbers and proving something about
addition.</p>
<p>We start by defining the type of natural numbers. There are infinitely many natural numbers, so of
course they must be defined inductively. In fact, all type definitions are done with the Inductive
vernacular command, even if they are not in fact inductive. Coq’s Inductive is analogous to
Haskell’s data and OCaml’s type (with the added power of dependent types).</p>
<p>We define two constructors: <code>O</code>, representing 0, and <code>S</code>, which when applied to the natural number n
produces the representation of the number <code>n + 1</code> (S as in &quot;successor&quot;). To give a concrete example, 3
would be represented in this encoding as <code>S (S (S 0)))</code> i.e <code>1 + (1 + (1 + 0))</code>.</p>
<pre><code class="language-Coq">Inductive nat : Type :=
  | O
  | S (n : nat).
</code></pre>
<p>This is an example of a unary number representation. It can often be helpful to represent numbers
this way, since the inductive nature of the definition lends itself to inductive proof techniques.</p>
<p>Let’s continue by defining addition over our nat type:</p>
<pre><code class="language-Coq">Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O ⇒ m
  | S n' ⇒ S (plus n' m)
  end.
</code></pre>
<p>Here we define a recursive function (a <code>Fixpoint</code>) that takes two numbers n and m and returns the
sum of these two numbers. The implementation is defined recursively with pattern matching. You might
think of this definition as “unwrapping” each application of S from the first argument until we
reach its O. Then we start wrapping the second argument in the same number of Ss.</p>
<p>Now we’re ready to prove something! Let’s prove that <code>0 + n == n</code>:</p>
<pre><code class="language-Coq">Theorem plus_O_n :
  forall n : nat, plus O n = n.
Proof.
  intros n. simpl. reflexivity.
Qed.
</code></pre>
<p>We first define our theorem and give it a name (plus_O_n). Then we define the proof goal, in the
form of a dependent type. We claim that for all n, where n is an instance of our nat type, 0 + n is
equal to n. Finally, we construct a proof, in the form of a series of tactics. Tactics may implement
either backwards inference (transforming the goal) or forwards inference (transforming evidence).</p>
<p>The best way to understand the system is to run the software yourself, and play around with the
various tactics. In this case the goal is simple enough; once we’ve specified that the proof will be
on n, Coq is able to simplify plus O n into n, leaving us the goal n = n. This turns out to be true
by the definition of equality, and we invoke definitional equality by reflexivity.</p>
<p>More complicated proofs do not typically require proving basic facts about arithmetic, because Coq
ships a substantial standard library of useful definitions and theorems. The above example hopefully
serves to illustrate the formal nature of proof in these systems. In many cases it can be
surprisingly hard to convince the kernel of the correctness of a statement that seems “obviously”
true.</p>
<h2 id="act-export"><a class="header" href="#act-export">Act Export</a></h2>
<p>Let’s take a look at using Coq to prove properties about a specification that is too difficult for
the SMT backend. The following defines a contract that implements exponentiation via repeated
multiplication. The contract is initialized with a base (<code>b</code>) and an exponent (<code>e</code>). <code>exp()</code> can then be
repeatedly called until <code>e</code> is 1, and the result can then be read from the storage variable <code>r</code>. While
obviously artificial, this example does highlight a key shortcoming of the SMT based analysis:
exponentiation with a symbolic exponent is simply inexpressible in the smt-lib language used by all
major SMT solvers, and so any contract making use of exponentiation where the exponent is a variable
of some kind (e.g. calldata, storage) will be impossible to verify using SMT. Coq has no such
restrictions, and we can export the spec below and prove correctness there.</p>
<pre><code class="language-act">constructor of Exponent
interface constructor(uint _b, uint _e)

iff

    _e &gt; 0

creates

    uint b := _b
    uint e := _e
    uint r := _b
</code></pre>
<pre><code class="language-act">behaviour exp of Exponent
interface exp()

iff

    e &gt; 1

iff in range uint

    r * b
    e - 1

storage

    r =&gt; r * b
    e =&gt; e - 1
    b
</code></pre>
<p>You can export the spec into Coq by running <code>act coq --file Exponent.act</code>. This will create a file called Exponent.v which contains a model of the above Act specification in Coq:</p>
<pre><code class="language-Coq">(* --- GENERATED BY ACT --- *)

Require Import Coq.ZArith.ZArith.
Require Import ActLib.ActLib.
Require Coq.Strings.String.

Module Str := Coq.Strings.String.
Open Scope Z_scope.

Record State : Set := state
{ b : Z
; e : Z
; r : Z
}.

Definition exp0 (STATE : State)  :=
state (b STATE) (((e STATE) - 1)) (((r STATE) * (b STATE))).

Definition Exponent0 (_b : Z) (_e : Z) :=
state (_b) (_e) (_b).

Inductive reachable  : State -&gt; State -&gt; Prop :=
| Exponent0_base : forall (_b : Z) (_e : Z),
     (_e &gt; 0)
  -&gt; ((0 &lt;= _b) /\ (_b &lt;= (UINT_MAX 256)))
  -&gt; ((0 &lt;= _e) /\ (_e &lt;= (UINT_MAX 256)))
  -&gt; reachable (Exponent0 _b _e) (Exponent0 _b _e)

| exp0_step : forall (BASE STATE : State),
     reachable BASE STATE
  -&gt; ((e STATE) &gt; 1)
  -&gt; ((0 &lt;= ((r STATE) * (b STATE))) /\ (((r STATE) * (b STATE)) &lt;= (UINT_MAX 256)))
  -&gt; ((0 &lt;= ((e STATE) - 1)) /\ (((e STATE) - 1) &lt;= (UINT_MAX 256)))
  -&gt; ((0 &lt;= (r STATE)) /\ ((r STATE) &lt;= (UINT_MAX 256)))
  -&gt; ((0 &lt;= (e STATE)) /\ ((e STATE) &lt;= (UINT_MAX 256)))
  -&gt; ((0 &lt;= (b STATE)) /\ ((b STATE) &lt;= (UINT_MAX 256)))
  -&gt; reachable BASE (exp0 STATE )
.
</code></pre>
<p>Let’s break this down a bit. We have a definition of contract storage State, which consists of three
variables <code>b</code>, <code>e</code> and <code>r</code>, all of type <code>Z</code>. <code>Z</code> is an integer type using a binary encoding from the
ZArith library bundled with Coq.</p>
<p>Next we have <code>exp0</code>, which defines how the state is updated by the exp behaviour, and <code>Exponent0</code> which
defines how the state variables are initialized by the constructor arguments.</p>
<p>Finally we have an Inductive Proposition reachable that defines the conditions under which a certain
state is reachable from another. There are two parts to this definition:</p>
<ul>
<li><code>Exponent0_base</code>: states that given two integers <code>_b</code> and <code>_e</code>, the initial state is reachable</li>
<li>from the initial state if <code>_e</code> and <code>_b</code> are in the range of a <code>uint256</code> and <code>_e</code> is greater than</li>
<li><code>0</code>. <code>exp0_step</code>: states that for a pair of states <code>BASE</code> and <code>STATE</code>, <code>exp0 STATE</code> (i.e. the</li>
<li>result of calling <code>exp()</code> against an arbitrary contract state) is reachable from <code>BASE</code> if <code>STATE</code></li>
<li>is reachable from <code>BASE</code>, all the state variables in <code>STATE (e, b, r)</code> are within the range of a</li>
<li><code>uint256</code>, the result of the calculations <code>r * b</code> and <code>e - 1</code> are within the range of a <code>uint256</code>,</li>
<li>and <code>e</code> is greater than 1.</li>
</ul>
<p>This gives us a pair of inference rules that we can use to prove facts about the set of reachable
states defined by the specification for the Exponent contract.</p>
<p>The core fact that we wish to prove is that when <code>e</code> is 1, <code>r</code> is equal to <code>b ^ e</code>. This can be
expressed in Coq as:</p>
<p><code>forall (base, s : State), reachable base s -&gt; e s = 1 -&gt; r s = (b base) ^ (e base)</code>. Expressed more
verbosely: for all states <code>base</code> and <code>s</code>, if <code>s</code> is reachable from <code>base</code>, and the value of <code>e</code> in
<code>s</code> is 1, then the result variable <code>r</code> in <code>s</code> is equal to <code>b</code> from base raised to the power of <code>e</code>
from base.</p>
<p>The full proof is reproduced below. While an explanation of each step is out of scope for this post
(and is anyway best made with the proof loaded into an interactive instance of the Coq prover like
proof general or CoqIde), we can give a broad strokes overview.</p>
<p>We must first define a helper fact <code>pow_pred</code> which simply states that given two integers <code>a</code> and
<code>e</code>, if e is greater than 0 then <code>a * a ^ (e - 1)</code> is equal to <code>a ^ e</code>. This fact is needed in the
later steps of the proof. The next step is to define a loop invariant for <code>exp()</code> (i.e. a fact that
is true before and after each loop iteration). This is the Lemma <code>invariant</code>, which states that for
every state <code>s</code> reachable from <code>base</code>, <code>r * b ^ (e - 1)</code> over <code>s</code> is equal to <code>b ^ e</code> over <code>base</code>.
Intuitively, this states that the partial result calculated so far (<code>r</code>), multiplied by the
remaining portion of the input calculation <code>b ^ (e - 1)</code> is equal to the final expected result.
Finally, given these two intermediate facts, we can discharge a proof for the correctness of
Exponent as defined above.</p>
<pre><code class="language-Coq">Require Import Exponent.Exponent.
Require Import ActLib.ActLib.
Require Import Coq.ZArith.ZArith.
Open Scope Z_scope.

Lemma pow_pred : forall a e, 0 &lt; e -&gt; a * a ^ (Z.pred e) = a ^ e.
Proof.
  intros.
  apply eq_sym.
  replace (a ^ e) with (a ^ (Z.succ (Z.pred e))).
  - apply Z.pow_succ_r.
    apply Zlt_0_le_0_pred.
    assumption.
  - rewrite (Z.succ_pred e).
    reflexivity.
Qed.

Lemma invariant : forall base s,
  reachable base s -&gt; (r s) * (b s) ^ ((e s) - 1) = (b base) ^ (e base).
Proof.
  intros base s H. induction H.
  - simpl.
    rewrite Z.sub_1_r.
    apply pow_pred.
    apply Z.gt_lt.
    assumption.
  - simpl.
    rewrite &lt;- IHreachable.
    rewrite Z.sub_1_r.
    rewrite &lt;- (pow_pred (b STATE) (e STATE - 1)).
    + rewrite Z.mul_assoc. reflexivity.
    + apply Z.gt_lt in H0.
      apply (proj1 (Z.sub_lt_mono_r 1 (e STATE) 1)).
      assumption.
Qed.

Theorem exp_correct : forall base s,
  reachable base s -&gt; e s = 1 -&gt; r s = (b base) ^ (e base).
Proof.
  intros base s H He.
  apply invariant in H.
  rewrite He in H. simpl in H.
  rewrite (Z.mul_1_r (r s)) in H.
  assumption.
Qed. Check exp_correct.
</code></pre>
<p>While this may seem like quite a lot of work to prove what looks like a pretty simple and obvious fact it is worth noting two things:</p>
<ul>
<li>A proof of this property is beyond the reach of any automated tool available today.</li>
<li>Our mind is full of hidden assumptions, and facts that may seem obvious are not always so. This is not the case for the Coq proof kernel, and once we have convinced it that something is true, we can be very sure that it really is.</li>
</ul>
<h1 id="hevm"><a class="header" href="#hevm">Hevm</a></h1>
<p>Act leverages the symbolic execution engine in hevm to provide a backend that can prove equivalence
between a contract specification and an implementation of that specification in EVM.</p>
<p>Two claims are generated for each behaviour, Pass and Fail. The Pass claim states that if all
preconditions in the iff block are true, then all executions will succeed, storage will be updated
according to the storage block, and the specified return value will, in fact, be returned. The Fail
claim states that should any of the preconditions be false, all executions will revert.</p>
<p>In both cases we begin the proof by constraining calldata to be of the form specified in the
behaviours’ interface blocks, as well as making the relevant assumptions depending on whether the
claim is Pass or Fail, and then symbolically executing the bytecode object with storage held to be
completely abstract.</p>
<p>This produces a tree of potential executions where each node represents a potential branching point,
and each leaf represents a possible final state of the contract after the execution of a single
call.</p>
<p>In the case of a Fail claim, we can then check that each leaf represents a state in which execution
has reverted, while for a Pass claim we can check that storage has been updated as expected, and
that the contents of the return buffer matches what was specified in the behaviour’s returns block.</p>
<p>As an example, consider the following contract:</p>
<pre><code>contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        require(x &gt; 100);
        val = x;
        return x;
    }
}
</code></pre>
<p>We can represent this in Act as:</p>
<pre><code>constructor of Simple
interface constructor()

creates

  uint val := 0
behaviour set of Simple
interface set(uint x)

iff

  x &gt; 100

storage

  val =&gt; x

returns x
</code></pre>
<p>Act needs to have access to the storage layout metadata output by solc to compute the index in storage for each variable mentioned in the spec, so we need to pass a solc output json when trying to prove equivalence.</p>
<pre><code>&gt; act hevm --spec src/simple.act --soljson out/dapp.sol.json
checking postcondition...
Q.E.D.
Successfully proved set(Pass), 2 cases.
checking postcondition...
Q.E.D.
Successfully proved set(Fail), 2 cases.
==== SUCCESS ====
All behaviours implemented as specified ∎.
</code></pre>
<p>If we try to prove equivalence of the spec and a faulty implementation like the one below:</p>
<pre><code class="language-solidity">contract Simple {
    uint val;

    function set(uint x) external payable returns (uint) {
        require(x &gt; 100);
        if (x == 2000) {
          val = x + 1;
        } else {
          val = x;
        }
        return x;
    }
}
</code></pre>
<p>Then Act will give us a counterexample showing a case where the implementation differs from the specification:</p>
<pre><code>&gt; act hevm --spec src/simple.act --soljson out/dapp.sol.json
checking postcondition...
Calldata:
0x60fe47b100000000000000000000000000000000000000000000000000000000000007d0
Caller:
0x0000000000000000000000000000000000000000
Callvalue:
0
Failed to prove set(Pass)
checking postcondition...
Q.E.D.
Successfully proved set(Fail), 2 cases.
==== FAILURE ====
1 out of 2 claims unproven:

1	Failed to prove set(Pass)
</code></pre>
<h1 id="internals"><a class="header" href="#internals">Internals</a></h1>
<h2 id="the-act-ast-type"><a class="header" href="#the-act-ast-type">The Act AST Type</a></h2>
<p>All act specs are transformed into typed AST instances. The definition of this AST type can be found
in <a href="https://github.com/ethereum/act/blob/master/src/Syntax/TimeAgnostic.hs">Syntax/TimeAgnostic.hs</a>.</p>
<p>The top level datatype here is a <code>Claim</code>, and the output of the frontend states is a list of
(<code>Timed</code>) claims. A <code>Claim</code> is a sum type (enum) with four potential values:</p>
<ul>
<li><code>C</code>: constructor</li>
<li><code>B</code>: behaviour</li>
<li><code>I</code>: invariant</li>
<li><code>S</code>: typing information for storage variables</li>
</ul>
<h3 id="pass-and-fail-claims"><a class="header" href="#pass-and-fail-claims">Pass and Fail Claims</a></h3>
<p>Act specs are intended to be fully exhaustive, for this reason we generate two claims from each
constructor / behaviour in the spec:</p>
<ol>
<li><code>Pass</code>: The Pass claim states that if all preconditions in the iff block are true, then all executions will succeed, storage will be updated according to the storage block, and the specified return value will, in fact, be returned.</li>
<li><code>Fail</code>: The Fail claim states that should any of the preconditions be false, all executions will revert.</li>
</ol>
<p>Taken together a succesfull proof of these claims ensures that a given bytecode object implements
only the behaviour specified in act <em>and nothing else</em>.</p>
<h3 id="timed-vs-untimed-instances"><a class="header" href="#timed-vs-untimed-instances">Timed vs Untimed Instances</a></h3>
<p>AST instances can be either <code>Timed</code> (explicitly timed storage references) or <code>Untimed</code> (implicitly
timed storage references), and this distinction is reflected at the type level (the <code>t</code> parameter in
most of the data type definitions).</p>
<p>In some parts of an act spec (<code>returns</code> and <code>ensures</code> blocks), storage references must be qualified
with either the <code>pre</code> or <code>post</code> operator to disambiguate references to storage in the pre or post
state. In other blocks storage references are either implicitly refering to both pre and post states
(<code>invariants</code>), or to the pre state only (e.g. <code>storage</code>). In order to simplify implementation in
the various backends, there is a frontend stage (<code>annotate</code>) that makes all implicit timings
explicit. The type parameter allows us to enforce the invariant that all backend stages always
operate on <code>Timed</code>  AST instances.</p>
<h2 id="compilation-pipeline"><a class="header" href="#compilation-pipeline">Compilation Pipeline</a></h2>
<p>The act compilation pipeline is as follows:</p>
<pre class="mermaid">flowchart LR;
    Source --&gt; Lexer
    Lexer --&gt; Parser;
    Parser --&gt; Type[Type Checker];
    Type --&gt; Annotate;
    Annotate --&gt; Enrich;
    Enrich --&gt; SMT;
    Enrich --&gt; Coq;
    Enrich --&gt; Hevm;
    Enrich --&gt; K;
</pre>
<h3 id="lexer"><a class="header" href="#lexer">Lexer</a></h3>
<p>Converts the source code into a sequence of tokens that can be consumed by the parser. We use
<a href="https://www.haskell.org/alex/">alex</a> to generate a lexer from the specification in
<a href="https://github.com/ethereum/act/blob/master/src/Lex.x">Lex.x</a>.</p>
<h3 id="parser"><a class="header" href="#parser">Parser</a></h3>
<p>Parses a sequence of tokens into an untyped AST. We use <a href="https://www.haskell.org/happy/">happy</a> to
generate a parser from the specification in
<a href="https://github.com/ethereum/act/blob/master/src/Parse.y">Parse.y</a>. The untyped AST is defined in
<a href="https://github.com/ethereum/act/blob/master/src/Syntax/Untyped.hs">Syntax/Untyped.hs</a>.</p>
<h3 id="type-checker"><a class="header" href="#type-checker">Type Checker</a></h3>
<p>The type checker takes an untyped AST, checks that none of the typing rules are violated, and
produces a typed AST. The typechecker is defined in
<a href="https://github.com/ethereum/act/blob/master/src/Type.hs">Type.hs</a> and the core typed AST definition
is in
<a href="https://github.com/ethereum/act/blob/master/src/Syntax/TimeAgnostic.hs">Syntax/TimeAgnostic.hs</a>.
The meaning of the timing parameter to the AST is described below in
<a href="internals.html#timed-vs-untimed-ast-instances">Timed vs Untimed AST instances</a>.</p>
<h3 id="annotation"><a class="header" href="#annotation">Annotation</a></h3>
<p>The annotate stage makes any implicit timings explicit. This stage is implemented in
<a href="https://github.com/ethereum/act/blob/master/src/Syntax/Annotated.hs">Syntax/Annotated.hs</a>.</p>
<h3 id="enrichment"><a class="header" href="#enrichment">Enrichment</a></h3>
<p>The enrich stage adds preconditions to all behaviour / constructor / invariant instances based on
the types of all variable references. This staged is implemented in
<a href="https://github.com/ethereum/act/blob/master/src/Enrich.hs">Enrich.hs</a>.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Stages that need to present errors to the user should return an instance of the <code>Error</code> type defined
in <a href="https://github.com/ethereum/act/blob/master/src/Error.hs">Error.hs</a>. This is a modified instance
of <a href="https://hackage.haskell.org/package/validation-1.1.2">Data.Validation</a> specialised to the act
context. This type allows us to accumulate multiple error messsages (useful if e.g. multiple syntax
errors are present), and we also have unified routines to pretty print these messages.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
